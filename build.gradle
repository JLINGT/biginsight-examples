import static org.gradle.testkit.runner.TaskOutcome.*
import com.jcraft.jsch.JSchException
import javax.net.ssl.*
import groovyx.net.http.RESTClient
import groovy.json.JsonSlurper


buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.codehaus.groovy:groovy-all:2.0.5'
        classpath 'jline:jline:2.12'
        classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.1'
        classpath gradleTestKit()
    }
}

plugins {
  id 'org.hidetake.ssh' version '1.5.0'
}

// get the cluster connection details
Properties props = new Properties()
props.load(new FileInputStream("$projectDir/connection.properties"))

// extract BigInsights hostname from the gateway url
def matcher = props.gateway =~ /^(https?:\/\/)([^:^\/]*)(:\d*)?(.*)?.*$/

def mastermanager_hostname = matcher[0][2] 

def master2_hostname = mastermanager_hostname.replace('mastermanager', 'master-2')

// setup the connection details for ssh
remotes {
    bicluster {
       host = mastermanager_hostname
       user = props.username
       password = props.password
    }
    bicluster_master2 {
       host = master2_hostname
       user = props.username
       password = props.password
    }
}

ssh.settings {
    if (props.known_hosts == 'allowAnyHosts') {
        // disable ssh host key verification 
        knownHosts = allowAnyHosts
    }
}

////////////////////////////////////////////////////////////////////////////////

// verify Ssh connectivity by attempting a SSH session

task verifySshConnectivity << {

    try {
        ssh.run {
            session(remotes.bicluster) {
                execute "echo successfully connected to ${mastermanager_hostname} over ssh"
            }
        }
    } catch (JSchException e) {
        System.err.println "** SSH error: ${e.message} - some tests will fail **"
        System.err.println "   Resolution: ssh into ${mastermanager_hostname} or set known_hosts:allowAnyHosts in connection.properties"
    }

    if (master2_hostname != mastermanager_hostname) {
        try {
            ssh.run {
                session(remotes.bicluster_master2) {
                    execute "echo successfully connected to ${master2_hostname} over ssh"
                }
            }
        } catch (JSchException e) {
            System.err.println "** SSH error: ${e.message} - some tests will fail **"
            System.err.println "   Resolution: ssh into ${master2_hostname} or set known_hosts:allowAnyHosts in connection.properties"
        }
    }
}

task verifyCertificate << {

    def certfile = file('./certificate')

    if (!certfile.exists()) {
        System.err.println "** ${certfile.absolutePath} not found - some tests will fail **"
        System.err.println "   Resolution: save the server's certificate as per the biginsight-examples project README"
        return
    }

    def host = mastermanager_hostname
    def port = 9443
    def cert

    def certtext

    def trustManager = [
        checkClientTrusted: { chain, authType ->  },
        checkServerTrusted: { chain, authType -> cert = chain[0] },
        getAcceptedIssuers: { null }
    ] as X509TrustManager

    def context = SSLContext.getInstance("TLS")
    context.init(null, [trustManager] as TrustManager[], null)
    context.socketFactory.createSocket(host, port as int).with {
        startHandshake()
        close()
    }

    certtext = "-----BEGIN CERTIFICATE-----\n" + \
               "${cert.encoded.encodeBase64(true)}\n" + \
               "-----END CERTIFICATE-----"

    def certfiletext = certfile.text

    if (certtext.replaceAll("\\s", "") != certfiletext.replaceAll("\\s", "")) {
        System.err.println "** Certificate error:  SSL Certificate of server does not match ${certfile.absolutePath} - some tests will fail **"
        System.err.println "   Resolution: save the server's certificate as per the biginsight-examples project README"
    }
}

task verifyConfig(dependsOn: [verifyCertificate, verifySshConnectivity]) << {
}

////////////////////////////////////////////////////////////////////////////////

// Methods and task to pretty print cluster info

def termWidth() {
    // jline doesn't play nicely on some windows machines
    try {
        return  jline.TerminalFactory.get().getWidth()
    } catch (Exception e) {
        return 80
    }
}

def printSep() {
    println "-" * termWidth()
}

def printCenter(text) {
    print " " * ((termWidth() / 2) - (text.length()/2)) 
    println text
}

task('ClusterDetails') {

    printSep()
    printCenter("\033[1mCLUSTER DETAILS\033[0m")
    printSep()
    println "Ambari URL         ::      https://${mastermanager_hostname}:9443/"
    println "BigInsights URL    ::      https://${mastermanager_hostname}:8443/gateway/default/BigInsightsWeb/index.html"
    println "YARN URL           ::      https://${mastermanager_hostname}:8443/gateway/yarnui/yarn/apps"
    println "Master Mgr SSH URL ::      ssh://${props.username}@${mastermanager_hostname}"
    // Basic plan doesn't have a master2
    if (master2_hostname != mastermanager_hostname) {
        println "Master 2   SSH URL ::      ssh://${props.username}@${master2_hostname}"
    }
    printSep()
}

////////////////////////////////////////////////////////////////////////////////

// methods and tasks to test (build) example projects

task('QueryAmbariServices') {

    def ambariUrl =  props.ambariUrl
    def ambariUser = props.ambariUsername
    def ambariPassword = props.ambariPassword

    def client = new RESTClient( ambariUrl )
    client.ignoreSSLIssues()

    client.headers['Authorization'] = 'Basic ' + "$ambariUser:$ambariPassword".getBytes('iso-8859-1').encodeBase64()
    client.headers['X-Requested-By'] = 'ambari'

    // Make REST call to get clusters
    def resp = client.get( path : 'api/v1/clusters' )

    assert resp.status == 200  // HTTP response code; 404 means not found, etc.

    // Parse output to JSON
    def jsonSlurper = new JsonSlurper()
    def object = jsonSlurper.parseText(resp.data.text)

    // Get Cluster Name
    def clusterName = object.items.Clusters[0].cluster_name

    // Make REST to get services
    def respServices = client.get( path : 'api/v1/clusters/' + clusterName + '/services' )

    assert respServices.status == 200  // HTTP response code; 404 means not found, etc.

    // Get services
    def object_services = jsonSlurper.parseText(respServices.data.text)

    def object_service_list = []
    object_services.items.eachWithIndex { serviceName,  index ->
        object_service_list << serviceName.ServiceInfo.service_name
    } 

    project.ext.set('ambari_services',  object_service_list)
}


def buildProject(proj, services=[]) {

        if (!project.ext.get('ambari_services').containsAll(services)) {
            println "Test skipped ./examples/${proj} [Required service(s) '${services.join(', ')}' not installed]"
        } else {
            try {
                GradleRunner.create()
                        .withProjectDir(file("./examples/${proj}/"))
                        .withArguments('clean')
                        .build()
            } catch (Exception e) {
                // noop - some projects don't have clean tasks
            }

            try {
                FileWriter writer = new FileWriter("build/test/${proj}.txt")

                GradleRunner.create()
                        .withProjectDir(file("./examples/${proj}/"))
                        .forwardStdError(writer)
                        .forwardStdOutput(writer)
                        .withArguments(['Example', '-PdebugExample'])
                        .build()

                writer.close()

            } catch (Exception e) { 
                println "Test failed  ./examples/${proj}"
                return
            }

            println "Test passed  ./examples/${proj}"
        }
}

task testSetup(dependsOn: verifyConfig) {
    
    delete('build')
    mkdir('build/test')
}


task baseTest(dependsOn: testSetup) << {
    println "Running base tests"

    [
      'WebHdfsGroovy':['KNOX'],
      'WebHdfsCurl':['KNOX'],
      'HiveGroovy':['HIVE'],
      'HiveJava':['HIVE'],
      'SparkWordCount':['SPARK'],
      'SparkStreamingPythonSsh':['SPARK'],
      'SparkObjectStoreIntegration':['SPARK'],
      'CloudantPullWithSpark':['SPARK'],
      'CloudantPushWithSpark':['SPARK'],
      'DashDBPullWithSpark':['SPARK'],
      'DashDBPushWithSpark':['SPARK'],
      'OozieWorkflowMapReduce':['KNOX', 'OOZIE', 'MAPREDUCE2'],
      'OozieWorkflowSpark':['KNOX', 'OOZIE', 'SPARK'],
      'OozieWorkflowCurl':['KNOX', 'OOZIE', 'MAPREDUCE2'],
      'WebHCatMapReduce':['KNOX', 'MAPREDUCE2'],
      'WebHCatPig':['KNOX', 'PIG'],
      'WebHCatHive':['KNOX', 'HIVE'],
      'HBase':['KNOX', 'HBASE'],
      'HBaseJava':['KNOX', 'HBASE'],
      'HBaseManipulateSchemaAndPerformCRUD':['KNOX', 'HBASE'],
    ]
    .each() { proj, service -> buildProject(proj, service) }

    // These examples are interactive so aren't easy to automate
    [
      'HiveBeeline',
      'Knoxshell',
    ]
    .each() { 
        println "Test skipped ./examples/${it} [interactive examples are not tested]"
    }
   
    // examples not implemented due to upstream dependencies not being met 
    [
      'Flume',
      'Sqoop',
      'Solr',
      'Kafka',
    ]
    .each() { 
        println "Test skipped ./examples/${it} [example not implemented due to known issue with BIoC clusters]"
    }
}

// TODO split this by module
task xTest(dependsOn: baseTest) << {

    println "Running BigX tests"

    [
      'BigR':['BIGR'], 
      'BigSQLGroovy':['BIGSQL'], 
      'BigSQLJava':['BIGSQL'],
    ]
    .each() { proj, service -> buildProject(proj, service) }
}

task test(dependsOn: xTest) << {
    println "Finished running tests.  *** Test output can be found in '${projectDir}/build/test/' ***"
}


////////////////////////////////////////////////////////////////////////////////

